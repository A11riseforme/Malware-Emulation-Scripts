package main

import (
    "fmt"
    "log"
    "net/http"
    "strings"
    "math/rand"
    "io"
    "os"
    "io/ioutil"
    "time"
    "flag"
    "strconv"
    "sync"

    "github.com/kabukky/httpscerts"
)

const server = "0.0.0.0"

var commands = []string{"whoami", "hostname", "ipconfig", "systeminfo", "tasklist"}

// When http get is received, server interprets it as beaconing activity
// randomly generate value which will determine if a command is returned to beaconer
// When http post is received, server interpreets it as output of command
func handler(w http.ResponseWriter, r *http.Request) {
    hostname := strings.Split(r.Header.Get("User-Agent"), " ")
    log.Printf("Beacon received from %s", hostname[len(hostname)-1])

    if r.Method == http.MethodGet {
        if rand.Float64() > 0.5 {
            command := commands[rand.Intn(len(commands))]
            io.WriteString(w, command)
            log.Printf("Sent command %s to %s", command, hostname[len(hostname)-1])
        }
    } else if r.Method == http.MethodPost {
        data, _ := ioutil.ReadAll(r.Body)
        log.Printf("Command output received from %s: %s", hostname[len(hostname)-1], data)
    }
}

func main() {
    var (
        http_port = flag.Int("http-port", 80, "Port to listen for HTTP connections")
        https_port = flag.Int("https-port", 8080, "Port to listen for HTTPS connections")
    )

    flag.Parse()

    file, _ := os.OpenFile("run.log", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)
    defer file.Close()
    mw := io.MultiWriter(os.Stdout, file)
    log.SetOutput(mw)

    http.HandleFunc("/", handler)
    
    //add seed to randomize when commands are returned by GET requests
    rand.Seed(time.Now().Unix())

    //check if cert files are available
    err := httpscerts.Check("cert.pem", "key.pem")
    if err != nil {
        err = httpscerts.Generate("cert.pem", "key.pem", "0.0.0.0:8080")
        if err != nil {
            log.Fatal("Error: Couldn't create https certs.")
        }
    }

    wg := new(sync.WaitGroup)
    wg.Add(2)

    go func() {
        log.Printf("Starting at HTTP Server at Port %d\n", *http_port)

        err1 := http.ListenAndServe(fmt.Sprintf("%s:%d", server, *http_port), nil)
        if err1 != nil {
            log.Fatal("ListenAndServe: ", err1)
        }
        wg.Done()
    }()

    go func() {
        log.Printf("Starting at HTTPS Server at Port %d\n", *https_port)

        err2 := http.ListenAndServeTLS(":" + strconv.Itoa(*https_port), "cert.pem", "key.pem", nil)
        if err2 != nil {
            log.Fatal("ListenAndServe: ", err2)
        }
        wg.Done()
    }()

    wg.Wait()

}