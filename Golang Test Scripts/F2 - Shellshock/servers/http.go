package main

// https://www.exploit-db.com/exploits/34900

import (
	"fmt"
	"flag"
	"io"
	"log"
	"net/http"
	"strings"
	"os"
	"os/exec"
)

const server = "0.0.0.0"

// Receive cgi bin request and connects to port specified.
func cgiHandler(w http.ResponseWriter, r *http.Request) {
	log.Printf("Received shellshock exploit at %s", r.URL.Path)

	useragent := r.Header.Get("User-Agent")
	command := strings.Replace(useragent, "() { :;}; /bin/bash -c /bin/bash -i >& ", "", -1)
	
	log.Printf("Trying to execute command %s", command)
	out, err := exec.Command(command).Output()
	if err != nil {
		log.Printf("Failed to execute command %s", err)

		w.Write([]byte("error"))
	} else {
		log.Printf("Successfully executed command")

		w.Write(out)
	}
}

func handler(w http.ResponseWriter, r *http.Request) {
	hostname := strings.Split(r.Header.Get("User-Agent"), " ")
	log.Printf("HTTP request received from %s", hostname[len(hostname)-1])
}

// Setup our HTTP server and route handlers.
func main() {
	var (
        port = flag.Int("port", 80, "Port to listen for HTTP connections")
    )

    flag.Parse()

    file, _ := os.OpenFile("run.log", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)
    defer file.Close()
    mw := io.MultiWriter(os.Stdout, file)
	log.SetOutput(mw)

	http.HandleFunc("/", handler)
	http.HandleFunc("/cgi-sys/entropysearch.cgi", cgiHandler)
	http.HandleFunc("/cgi-sys/defaultwebpage.cgi", cgiHandler)
	http.HandleFunc("/cgi-mod/index.cgi", cgiHandler)
	http.HandleFunc("/cgi-bin/test.cgi", cgiHandler)
	http.HandleFunc("/cgi-bin-sdb/printenv", cgiHandler)

	log.Printf("Starting at Port %d\n", *port)
	err := http.ListenAndServe(fmt.Sprintf("%s:%d", server, *port), nil)
	if err != nil {
		log.Fatal("ListenAndServe: ", err)
	}
}
