package main

import (
	// "fmt"
	"flag"
	"io"
	"os"
	"log"
	"strconv"
	"net"
	// "strings"

	"github.com/miekg/dns"
)


func handleDnsRequest(w dns.ResponseWriter, req *dns.Msg) {
	r := new(dns.Msg)
	r.SetReply(req)
	r.Authoritative = true

	q := req.Question[0]
	log.Printf("%s request for %s\n", dns.TypeToString[q.Qtype], q.Name)

	switch q.Qtype {
	case dns.TypeA:
		r.SetRcode(req, dns.RcodeNameError)
		break
		resp := new(dns.A)
		resp.Hdr = dns.RR_Header{
			Name:   q.Name,
			Rrtype: dns.TypeA,
			Class:  dns.ClassINET,
			Ttl:    0,
		}
		resp.A = net.ParseIP("0.0.0.0")
		r.Answer = append(r.Answer, resp)
	case dns.TypeAAAA:
		r.SetRcode(req, dns.RcodeNameError)
		break
		resp := new(dns.AAAA)
		resp.Hdr = dns.RR_Header{
			Name:   q.Name,
			Rrtype: dns.TypeAAAA,
			Class:  dns.ClassINET,
			Ttl:    0,
		}
		resp.AAAA = net.ParseIP("ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff")
		r.Answer = append(r.Answer, resp)
	}
	w.WriteMsg(r)
}

func main() {
	var (
        port = flag.Int("port", 53, "Port to listen for DNS connections")
    )

    flag.Parse()

    file, _ := os.OpenFile("run.log", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)
    defer file.Close()
    mw := io.MultiWriter(os.Stdout, file)
	log.SetOutput(mw)

	// attach request handler func
	dns.HandleFunc(".", handleDnsRequest)
	
	// start server
	log.Printf("Starting at Port %d\n", *port)

	server := &dns.Server{Addr: ":" + strconv.Itoa(*port), Net: "udp"}
	err := server.ListenAndServe()
	defer server.Shutdown()
	if err != nil {
		log.Fatalf("Failed to start server: %s\n ", err.Error())
	}
}
