package main

import (
	"time"
	"flag"
	"net"
	"io"
	"log"
	"strconv"
	"strings"
	"os"
	"math/rand"

	"../zeus"
	"../locky"
	"../nymaim"
	"github.com/miekg/dns"
)

type Config struct {
	ip string
	port int
	prefix string
	suffix string
	tld string
	date string
	offset int
	jitter float64 
	kill int
	seed int
	lockyconfig int
	nymaimwordlist string
}

var config Config

func main() {
	//Command line switches
	var (
		option = flag.Int("option", 1, "DGA Algorithm to run: 1 - Zeus, 2 - Locky, 3 - Nymaim2")

		ip = flag.String("ip", "0.0.0.0", "IP address of DNS Server")
		port = flag.Int("port", 53, "Port of DNS Server")
		prefix = flag.String("p", "", "Prefix added to hosts for easy searching")
		suffix = flag.String("s", "", "Suffix added to hosts for easy searching")
		tld = flag.String("t", "", "Fixed TLD instead of algorithm generated TLD (e.g. com)")
		date = flag.String("date", "", "Date to generate TLD for (DDMMYYYY), else default to current datetime")

		//time configuration
		offset = flag.Int("i", 60, "Min beacon interval (seconds)")
		jitter = flag.Float64("j", 0.0, "Beacon interval jitter fraction between 0 and 1")
		timeout = flag.Int("k", 20, "Beacon timeout (minutes)")
		
		//limit = flag.Int("limit", 50, "Number of domains to generate before exit (rec limit: )")
		
		//algo specific flags
		seed = flag.Int("seed", 0, "4 digit seed for locky domain generation")
		lockyConfig = flag.Int("c", 0, "Index of locky config to use")
		nymaimWordlist = flag.String("list", "", "JSON word list")

		hosts []string
	)

	flag.Parse()

	config = Config{*ip, *port, *prefix, *suffix, *tld, *date, *offset, *jitter, *timeout, *seed, *lockyConfig, *nymaimWordlist}

	file, _ := os.OpenFile("run.log", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)
    defer file.Close()
    mw := io.MultiWriter(os.Stdout, file)
	log.SetOutput(mw)

	t := time.Now().UTC()
	count := (config.kill * 60) / config.offset
	log.Printf("Resolving total of %d domains", count)

	if config.date != "" {
		//convert date 
		const format = "02012006"
		t, _ = time.Parse(format, config.date)
	}

	switch *option {
	case 1:	//zeus
		for i := uint32(0); i < uint32(count); i++ {
			domain, tld := zeus.Dga(t, i)
			hosts = append(hosts, buildDomain(config.prefix, config.suffix, config.tld, domain + "." + tld))
		} 
	case 2: //locky
		for i := uint32(0); i < uint32(count); i++ {
			domain, tld := locky.Dga(t, uint32(config.lockyconfig), i, uint32(config.seed))
			hosts = append(hosts, buildDomain(config.prefix, config.suffix, config.tld, domain + "." + tld))
		}
	case 3: //nymaim
		if config.nymaimwordlist == "" {
			config.nymaimwordlist, _ = os.Getwd()
			config.nymaimwordlist = config.nymaimwordlist + "\\..\\nymaim\\words.json"
		}
		hosts = nymaim.Dga(t, count, config.nymaimwordlist)
		for i, host := range hosts {
			hosts[i] = buildDomain(config.prefix, config.suffix, config.tld, host)
		}
	default:
		flag.PrintDefaults()
		os.Exit(1)
	}
	
	for i := 0; i < len(hosts); i++ {
		log.Printf("Resolving %s", hosts[i])
	
		dnsAQuery(config.ip, config.port, hosts[i])
		
		// sleep 1 second between each query
		// jitter required?
		sleepBeforeCheckIn()
	}
}

// assume that domain to be resolved only 2 levels
func buildDomain(prefix, suffix, tld, domain string) string {
	split := strings.Split(domain, ".")
	final := prefix + split[0] + suffix + "."

	if tld != "" {
		tld = strings.Replace(tld, ".", "", -1)
		final = final + tld
	} else {
		final = final + split[1]
	}
	return final
}

// sleep for beacon interval varied by jitter percentage
func sleepBeforeCheckIn() {
	jitter := time.Duration(0)

	if config.jitter != 0.0 {
		jitter = ( time.Duration(config.offset) + time.Duration(float64(config.offset)*config.jitter*(2*rand.Float64()-1)) ) * time.Second
	} else {
		jitter = time.Duration(config.offset) * time.Second
	}
	
	time.Sleep(jitter)
}

func dnsAQuery(ip string, port int, domain string) {
	if ip == "0.0.0.0" {
		//IP address for DNS Server is not provided
		//Use configured local DNS Server to resolve DNS query
		net.LookupIP(domain)
		// if err != nil {
		// 	log.Println(err)
		// }

		// for _, ip := range resp {
		// 	if ip.To4() != nil {
		// 		return ip.String()
		// 	}
		// }
	} else {
		//IP address for DNS Server is provided
		c := dns.Client{}
	    m := dns.Msg{}

	    m.SetQuestion(domain + ".", dns.TypeA)
		c.Exchange(&m, ip + ":" + strconv.Itoa(port))

		// if a, ok := in.Answer[0].(*dns.A); ok {
		// 	return a.A.String()
		// }
	}
	// return "0.0.0.0"	
}