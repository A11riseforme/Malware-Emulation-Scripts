## DNS Tunnel-based Exfil

The scripts emulate the malware behavior of exfiltrating sensitive data through DNS tunnel to the server

pre-configured domain(suppose you own `example.com` and a server with IP `7.7.7.7`):

|      Name      | Type | Content        |
| :------------: | ---- | -------------- |
|      tun       | NS   | ns.example.com |
| ns.example.com | A    | 7.7.7.7        |

so all the DNS query regarding `*.tun.example.com` will be relayed to `ns.example.com`, which resolves to the server that I have control of. 

All I need to do is to set up a listener on the server side, listen on the port 53 for UDP data, and parse as DNS query packet, and respond to it.

#### Current implementation:

This is what sender.py does:

1. check if the specific file exists, if not, generate a csv file containing 100 entries of PII data. Below assume `test.csv` is generated
2. send a initializing DNS TXT query of `SU5JVA==.dGVzdC5jc3Y=.tun.example.com`, where `SU5JVA==` is the base64 encoded from `INIT` and `dGVzdC5jc3Y=` is base64 encoded from `test.csv`
3. wait for the server to respond with the TXT record of the string `OK`
4. read the csv files 45 bytes by 45 bytes, encode it using base64, for example, `last name,first name,title,telephone number,s` will be encoded to `bGFzdCBuYW1lLGZpcnN0IG5hbWUsdGl0bGUsdGVsZXBob25lIG51bWJlcixz`
5. encode the ordinal number using base64, for example, `0` will be encoded to `MA==`. The ordinal number starts from 0 and wraps around 9. So the 10th DNS query will have the ordinal number of 0
6. piece up the encoded data, ordinal number and the base domain, get `bGFzdCBuYW1lLGZpcnN0IG5hbWUsdGl0bGUsdGVsZXBob25lIG51bWJlcixz.MA==.tun.websec.pw`. Send a DNS TXT query of this domain. 
7. Wait until the server respond with the TXT record of the string `OK`, go to step 4 and send the next 45 bytes of data.

Server.py will do the necessary check to make sure the data is in order and intended. Then will respond with `OK` and save the data to the file.

