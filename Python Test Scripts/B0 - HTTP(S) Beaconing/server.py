import sys
import random
import argparse
import base64
import os
import cgi
import ssl
import logging

try:
    from OpenSSL import crypto
except ImportError:
    print("Missing dependency pyOpenSSL: <https://pypi.org/project/pyOpenSSL/>. Please install it with `pip install pyOpenSSL`.")
    sys.exit(1)

if sys.version_info[0] == 2:
    from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler
    import SocketServer, threading
    from SocketServer import ThreadingMixIn
else:
    from http.server import HTTPServer, BaseHTTPRequestHandler
    import socketserver, threading
    from socketserver import ThreadingMixIn


# list of commands send to agent to execute
win_cmds = ['whoami /all', 'net user', 'netstat -ano', 'tasklist /svc', 'dir']
linux_cmds = ['whoami && id', 'netstat -antp', 'ifconfig -a', 'ps -aux', 'ls -al']

# defines the log format
LOG_FORMAT = "%(asctime)s.%(msecs)03d - %(levelname)s - %(message)s"
DATE_FORMAT = "%m/%d/%Y %H:%M:%S"
logging.basicConfig(filename='my.log', level=logging.INFO, format=LOG_FORMAT, datefmt=DATE_FORMAT)


# Thanks http://django-notes.blogspot.com/2012/02/generating-self-signed-ssl-certificate.html
def cert_generator(cert_dir, cert_file, key_file):
    """Generate a SSL certificate.

    If the cert_path and the key_path are present they will be overwritten.
    """
    if not os.path.exists(cert_dir):
        os.makedirs(cert_dir)
    cert_path = os.path.join(cert_dir, cert_file)
    key_path = os.path.join(cert_dir, key_file)
 
    if os.path.exists(cert_path):
        os.unlink(cert_path)
    if os.path.exists(key_path):
        os.unlink(key_path)
 
    # create a key pair
    key = crypto.PKey()
    key.generate_key(crypto.TYPE_RSA, 2048)
 
    # create a self-signed cert
    cert = crypto.X509()
    cert.get_subject().C = 'US'
    cert.get_subject().ST = 'Lorem'
    cert.get_subject().L = 'Ipsum'
    cert.get_subject().O = 'Lorem'
    cert.get_subject().OU = 'Ipsum'
    cert.get_subject().CN = 'Unknown'
    cert.set_serial_number(1000)
    cert.gmtime_adj_notBefore(0)
    cert.gmtime_adj_notAfter(10 * 365 * 24 * 60 * 60) 
    cert.set_issuer(cert.get_subject())
    cert.set_pubkey(key)
    cert.sign(key, 'sha1')
 
    with open(cert_path, 'wt') as fd: 
        fd.write(crypto.dump_certificate(crypto.FILETYPE_PEM, cert).decode())
 
    with open(key_path, 'wt') as fd: 
        fd.write(crypto.dump_privatekey(crypto.FILETYPE_PEM, key).decode())
 
    return cert_path, key_path


class CustomHTTPRequestHandler(BaseHTTPRequestHandler):

    def do_GET(self):
        logging.info("received http get request at {path} with headers: {header}".format(path=self.path,header=str(self.headers)))
        self.send_response(200)
        self.end_headers()
        try:
            # based on the OS, issue command to execute
            if self.headers['OS'] == 'nt':
                command = win_cmds[random.randrange(0,len(win_cmds))]
            else:
                command = linux_cmds[random.randrange(0,len(win_cmds))]
            logging.info("sending http response of data: {data}".format(data=command))
            self.wfile.write(command.encode())
        except:
            logging.info("sending http response of data: hello")
            self.wfile.write("hello".encode())


    def do_POST(self):
        logging.info("received http post request at {path}".format(path=self.path))
        self.send_response(200)
        self.end_headers()

        form = cgi.FieldStorage(
            fp = self.rfile,
            headers = self.headers,
            environ = {'REQUEST_METHOD': 'POST'}
        )
        
        if form.getvalue("hostname") and form.getvalue("output"):
            host = form.getvalue("hostname")
            output = form.getvalue("output")
            try:
                with open(host+'.txt','a+') as f:
                    f.write(base64.b64decode(output).decode())
                    f.write('-'*80+'\n')
                logging.info("sending http response of data: ok")
                self.wfile.write("ok".encode())
            except:
                logging.info("sending http response of data: error")
                self.wfile.write("error".encode())
        else:
            logging.info("sending http response of data: hello")
            self.wfile.write("hello".encode())


# HTTP server
class ThreadedHTTPServer(ThreadingMixIn, HTTPServer):
    """ This class allows to handle requests in separated threads.
    No further content needed, don't touch this. """


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description="HTTP(S) Beaconing server emulation")
    parser.add_argument("-port", type=int, help = "listening port, default to be 80 for http, and 4443 for https", required=False)
    parser.add_argument("-https", dest='https', help="start a HTTPS server", action='store_true')
    args = parser.parse_args()

    # generate self-signed cert
    cert_file = 'my_cert.crt'
    key_file = 'my_key.key'
    
    if not args.port:
        if args.https:
            port = 4443
        else:
            port = 80
    else:
        port = args.port

    # 'with' statement cannot be used in python2
    server = ThreadedHTTPServer(("0.0.0.0", port), CustomHTTPRequestHandler)
    if args.https:
        cert_generator('./', cert_file, key_file)
        server.socket = ssl.wrap_socket(server.socket, keyfile='my_key.key', certfile='my_cert.crt', server_side=True)
    print("serving at port {port}".format(port=port))
    server.serve_forever()